{"version":3,"file":"babylonjs.addons.min.js","mappings":"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","sources":["webpack://ADDONS/webpack/universalModuleDefinition","webpack://ADDONS/external umd {\"root\":\"BABYLON\",\"commonjs\":\"babylonjs\",\"commonjs2\":\"babylonjs\",\"amd\":\"babylonjs\"}","webpack://ADDONS/webpack/bootstrap","webpack://ADDONS/webpack/runtime/define property getters","webpack://ADDONS/webpack/runtime/hasOwnProperty shorthand","webpack://ADDONS/webpack/runtime/make namespace object","webpack://ADDONS/../../../dev/addons/src/htmlMesh/htmlMeshRenderer.ts","webpack://ADDONS/../../../../node_modules/tslib/tslib.es6.mjs","webpack://ADDONS/../../../dev/addons/src/htmlMesh/pointerEventsCapture.ts","webpack://ADDONS/../../../dev/addons/src/htmlMesh/pointerEventsCaptureBehavior.ts","webpack://ADDONS/../../../dev/addons/src/htmlMesh/fitStrategy.ts","webpack://ADDONS/../../../dev/addons/src/htmlMesh/htmlMesh.ts","webpack://ADDONS/./src/index.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"babylonjs\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"babylonjs-addons\", [\"babylonjs\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"babylonjs-addons\"] = factory(require(\"babylonjs\"));\n\telse\n\t\troot[\"ADDONS\"] = factory(root[\"BABYLON\"]);\n})((typeof self !== \"undefined\" ? self : typeof global !== \"undefined\" ? global : this), (__WEBPACK_EXTERNAL_MODULE__597__) => {\nreturn ","module.exports = __WEBPACK_EXTERNAL_MODULE__597__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import type { Scene } from \"core/scene\";\r\nimport { Matrix, Quaternion, Vector3 } from \"core/Maths/math\";\r\n\r\nimport type { HtmlMesh } from \"./htmlMesh\";\r\nimport { Camera } from \"core/Cameras/camera\";\r\nimport type { SubMesh } from \"core/Meshes/subMesh\";\r\nimport { RenderingGroup } from \"core/Rendering/renderingGroup\";\r\n\r\nimport type { Observer } from \"core/Misc/observable\";\r\nimport { Logger } from \"core/Misc/logger\";\r\nimport type { AbstractEngine } from \"core/Engines\";\r\n\r\nconst _positionUpdateFailMessage = \"Failed to update html mesh renderer position due to failure to get canvas rect.  HtmlMesh instances may not render correctly\";\r\nconst babylonUnitsToPixels = 100;\r\n\r\n/**\r\n * A function that compares two submeshes and returns a number indicating which\r\n * should be rendered first.\r\n */\r\ntype RenderOrderFunction = (subMeshA: SubMesh, subMeshB: SubMesh) => number;\r\n\r\ntype RenderLayerElements = {\r\n    container: HTMLElement;\r\n    domElement: HTMLElement;\r\n    cameraElement: HTMLElement;\r\n};\r\n\r\n// Returns a function that ensures that HtmlMeshes are rendered before all other meshes.\r\n// Note this will only be applied to group 0.\r\n// If neither mesh is an HtmlMesh, then the default render order is used\r\n// This prevents HtmlMeshes from appearing in front of other meshes when they are behind them\r\nconst renderOrderFunc = (defaultRenderOrder: RenderOrderFunction): RenderOrderFunction => {\r\n    return (subMeshA: SubMesh, subMeshB: SubMesh) => {\r\n        const meshA = subMeshA.getMesh();\r\n        const meshB = subMeshB.getMesh();\r\n\r\n        // Use property check instead of instanceof since it is less expensive and\r\n        // this will be called many times per frame\r\n        const meshAIsHtmlMesh = (meshA as any)[\"isHtmlMesh\"];\r\n        const meshBIsHtmlMesh = (meshB as any)[\"isHtmlMesh\"];\r\n        if (meshAIsHtmlMesh) {\r\n            return meshBIsHtmlMesh ? (meshA.absolutePosition.z <= meshB.absolutePosition.z ? 1 : -1) : -1;\r\n        } else {\r\n            return meshBIsHtmlMesh ? 1 : defaultRenderOrder(subMeshA, subMeshB);\r\n        }\r\n    };\r\n};\r\n\r\n/**\r\n * An instance of this is required to render HtmlMeshes in the scene.\r\n * if using HtmlMeshes, you must not set render order for group 0 using\r\n * scene.setRenderingOrder.  You must instead pass the compare functions\r\n * to the HtmlMeshRenderer constructor.  If you do not, then your render\r\n * order will be overwritten if the HtmlMeshRenderer is created after and\r\n * the HtmlMeshes will not render correctly (they will appear in front of\r\n * meshes that are actually in front of them) if the HtmlMeshRenderer is\r\n * created before.\r\n */\r\nexport class HtmlMeshRenderer {\r\n    private _containerId?: string;\r\n    private _inSceneElements?: RenderLayerElements | null;\r\n    private _overlayElements?: RenderLayerElements | null;\r\n    private _engine: AbstractEngine;\r\n\r\n    private _cache = {\r\n        cameraData: { fov: 0, position: new Vector3(), style: \"\" },\r\n        htmlMeshData: new WeakMap<object, { style: string }>(),\r\n    };\r\n    private _width = 0;\r\n    private _height = 0;\r\n    private _heightHalf = 0;\r\n\r\n    private _cameraWorldMatrix?: Matrix;\r\n\r\n    // Create some refs to avoid creating new objects every frame\r\n    private _temp = {\r\n        scaleTransform: new Vector3(),\r\n        rotationTransform: new Quaternion(),\r\n        positionTransform: new Vector3(),\r\n        objectMatrix: Matrix.Identity(),\r\n        cameraWorldMatrix: Matrix.Identity(),\r\n        cameraRotationMatrix: Matrix.Identity(),\r\n        cameraWorldMatrixAsArray: new Array(16),\r\n    };\r\n\r\n    // Keep track of DPR so we can resize if DPR changes\r\n    // Otherwise the DOM content will scale, but the mesh won't\r\n    private _lastDevicePixelRatio = window.devicePixelRatio;\r\n\r\n    // Keep track of camera matrix changes so we only update the\r\n    // DOM element styles when necessary\r\n    private _cameraMatrixUpdated = true;\r\n\r\n    // Keep track of position changes so we only update the DOM element\r\n    // styles when necessary\r\n    private _previousCanvasDocumentPosition = {\r\n        top: 0,\r\n        left: 0,\r\n    };\r\n\r\n    private _renderObserver: Observer<Scene> | null = null;\r\n\r\n    /**\r\n     * Contruct an instance of HtmlMeshRenderer\r\n     * @param scene\r\n     * @param options object containing the following optional properties:\r\n     * @returns\r\n     */\r\n    constructor(\r\n        scene: Scene,\r\n        {\r\n            parentContainerId = null,\r\n            _containerId = \"css-container\",\r\n            enableOverlayRender = true,\r\n            defaultOpaqueRenderOrder = RenderingGroup.PainterSortCompare,\r\n            defaultAlphaTestRenderOrder = RenderingGroup.PainterSortCompare,\r\n            defaultTransparentRenderOrder = RenderingGroup.defaultTransparentSortCompare,\r\n        }: {\r\n            parentContainerId?: string | null;\r\n            _containerId?: string;\r\n            defaultOpaqueRenderOrder?: RenderOrderFunction;\r\n            defaultAlphaTestRenderOrder?: RenderOrderFunction;\r\n            defaultTransparentRenderOrder?: RenderOrderFunction;\r\n            enableOverlayRender?: boolean;\r\n        } = {}\r\n    ) {\r\n        // Requires a browser to work.  Only init if we are in a browser\r\n        if (typeof document === \"undefined\") {\r\n            return;\r\n        }\r\n        this._containerId = _containerId;\r\n        this._init(scene, parentContainerId, enableOverlayRender, defaultOpaqueRenderOrder, defaultAlphaTestRenderOrder, defaultTransparentRenderOrder);\r\n    }\r\n\r\n    /**\r\n     * Dispose of the HtmlMeshRenderer\r\n     */\r\n    public dispose() {\r\n        if (this._renderObserver) {\r\n            this._renderObserver.remove();\r\n            this._renderObserver = null;\r\n        }\r\n\r\n        this._overlayElements?.container.remove();\r\n        this._overlayElements = null;\r\n\r\n        this._inSceneElements?.container.remove();\r\n        this._inSceneElements = null;\r\n    }\r\n\r\n    protected _init(\r\n        scene: Scene,\r\n        parentContainerId: string | null,\r\n        enableOverlayRender: boolean,\r\n        defaultOpaqueRenderOrder: RenderOrderFunction,\r\n        defaultAlphaTestRenderOrder: RenderOrderFunction,\r\n        defaultTransparentRenderOrder: RenderOrderFunction\r\n    ): void {\r\n        // Requires a browser to work.  Only init if we are in a browser\r\n        if (typeof document === \"undefined\") {\r\n            return;\r\n        }\r\n\r\n        // Create the DOM containers\r\n        let parentContainer = parentContainerId ? document.getElementById(parentContainerId) : document.body;\r\n\r\n        if (!parentContainer) {\r\n            parentContainer = document.body;\r\n        }\r\n\r\n        // if the container already exists, then remove it\r\n        const inSceneContainerId = `${this._containerId}_in_scene`;\r\n        this._inSceneElements = this._createRenderLayerElements(inSceneContainerId);\r\n\r\n        parentContainer.insertBefore(this._inSceneElements.container, parentContainer.firstChild);\r\n\r\n        if (enableOverlayRender) {\r\n            const overlayContainerId = `${this._containerId}_overlay`;\r\n            this._overlayElements = this._createRenderLayerElements(overlayContainerId);\r\n            const zIndex = +(scene.getEngine().getRenderingCanvas()!.style.zIndex ?? \"0\") + 1;\r\n            this._overlayElements.container.style.zIndex = `${zIndex}`;\r\n            this._overlayElements.container.style.pointerEvents = \"none\";\r\n            parentContainer.insertBefore(this._overlayElements.container, parentContainer.firstChild);\r\n        }\r\n        this._engine = scene.getEngine();\r\n        const clientRect = this._engine.getRenderingCanvasClientRect();\r\n        if (!clientRect) {\r\n            throw new Error(\"Failed to get client rect for rendering canvas\");\r\n        }\r\n\r\n        // Set the size and resize behavior\r\n        this._setSize(clientRect.width, clientRect.height);\r\n\r\n        this._engine.onResizeObservable.add(() => {\r\n            const clientRect = this._engine.getRenderingCanvasClientRect();\r\n            if (clientRect) {\r\n                this._setSize(clientRect.width, clientRect.height);\r\n            }\r\n        });\r\n\r\n        let projectionObs: Observer<Camera>;\r\n        let matrixObs: Observer<Camera>;\r\n\r\n        const observeCamera = () => {\r\n            const camera = scene.activeCamera;\r\n            if (camera) {\r\n                projectionObs = camera.onProjectionMatrixChangedObservable.add(() => {\r\n                    this._onCameraMatrixChanged(camera);\r\n                });\r\n                matrixObs = camera.onViewMatrixChangedObservable.add(() => {\r\n                    this._onCameraMatrixChanged(camera);\r\n                });\r\n            }\r\n        };\r\n\r\n        observeCamera();\r\n\r\n        scene.onActiveCameraChanged.add(() => {\r\n            if (projectionObs) {\r\n                scene.activeCamera?.onProjectionMatrixChangedObservable.remove(projectionObs);\r\n            }\r\n            if (matrixObs) {\r\n                scene.activeCamera?.onViewMatrixChangedObservable.remove(matrixObs);\r\n            }\r\n            observeCamera();\r\n        });\r\n\r\n        // We need to make sure that HtmlMeshes are rendered before all other meshes\r\n        // so that they don't appear in front of meshes that are actually in front of them\r\n        // Updating the render order isn't ideal, but it is the only way to acheive this\r\n        // The implication is that an app using the HtmlMeshRendered must set the scene render order\r\n        // via the HtmlMeshRendered constructor\r\n        const opaqueRenderOrder = renderOrderFunc(defaultOpaqueRenderOrder);\r\n        const alphaTestRenderOrder = renderOrderFunc(defaultAlphaTestRenderOrder);\r\n        const transparentRenderOrder = renderOrderFunc(defaultTransparentRenderOrder);\r\n        scene.setRenderingOrder(0, opaqueRenderOrder, alphaTestRenderOrder, transparentRenderOrder);\r\n\r\n        this._renderObserver = scene.onBeforeRenderObservable.add(() => {\r\n            this._render(scene, scene.activeCamera as Camera);\r\n        });\r\n    }\r\n\r\n    private _createRenderLayerElements(containerId: string): RenderLayerElements {\r\n        const existingContainer = document.getElementById(containerId);\r\n        if (existingContainer) {\r\n            existingContainer.remove();\r\n        }\r\n        const container = document.createElement(\"div\");\r\n        container.id = containerId;\r\n        container.style.position = \"absolute\";\r\n        container.style.width = \"100%\";\r\n        container.style.height = \"100%\";\r\n        container.style.zIndex = \"-1\";\r\n\r\n        const domElement = document.createElement(\"div\");\r\n        domElement.style.overflow = \"hidden\";\r\n\r\n        const cameraElement = document.createElement(\"div\");\r\n\r\n        cameraElement.style.webkitTransformStyle = \"preserve-3d\";\r\n        cameraElement.style.transformStyle = \"preserve-3d\";\r\n\r\n        cameraElement.style.pointerEvents = \"none\";\r\n\r\n        domElement.appendChild(cameraElement);\r\n        container.appendChild(domElement);\r\n        return {\r\n            container,\r\n            domElement,\r\n            cameraElement,\r\n        };\r\n    }\r\n\r\n    protected _getSize(): { width: number; height: number } {\r\n        return {\r\n            width: this._width,\r\n            height: this._height,\r\n        };\r\n    }\r\n\r\n    protected _setSize(width: number, height: number): void {\r\n        this._width = width;\r\n        this._height = height;\r\n        this._heightHalf = this._height / 2;\r\n\r\n        if (!this._inSceneElements || !this._overlayElements) {\r\n            return;\r\n        }\r\n\r\n        const domElements = [this._inSceneElements!.domElement, this._overlayElements!.domElement, this._inSceneElements!.cameraElement, this._overlayElements!.cameraElement];\r\n        domElements.forEach((dom) => {\r\n            if (dom) {\r\n                dom.style.width = `${width}px`;\r\n                dom.style.height = `${height}px`;\r\n            }\r\n        });\r\n    }\r\n\r\n    // prettier-ignore\r\n    protected _getCameraCSSMatrix(matrix: Matrix): string {\r\n        const elements = matrix.m;\r\n        return `matrix3d(${\r\n            this._epsilon( elements[0] )\r\n        },${\r\n            this._epsilon( - elements[1] )\r\n        },${\r\n            this._epsilon( elements[2] )\r\n        },${\r\n            this._epsilon( elements[3] )\r\n        },${\r\n            this._epsilon( elements[4] )\r\n        },${\r\n            this._epsilon( - elements[5] )\r\n        },${\r\n            this._epsilon( elements[6] )\r\n        },${\r\n            this._epsilon( elements[7] )\r\n        },${\r\n            this._epsilon( elements[8] )\r\n        },${\r\n            this._epsilon( - elements[9] )\r\n        },${\r\n            this._epsilon( elements[10] )\r\n        },${\r\n            this._epsilon( elements[11] )\r\n        },${\r\n            this._epsilon( elements[12] )\r\n        },${\r\n            this._epsilon( - elements[13] )\r\n        },${\r\n            this._epsilon( elements[14] )\r\n        },${\r\n            this._epsilon( elements[15] )\r\n        })`;\r\n    }\r\n\r\n    // Convert a Babylon world matrix to a CSS matrix\r\n    // This also handles conversion from BJS left handed coords\r\n    // to CSS right handed coords\r\n    // prettier-ignore\r\n    protected _getHtmlContentCSSMatrix(matrix: Matrix, useRightHandedSystem: boolean): string {\r\n        const elements = matrix.m;\r\n        // In a right handed coordinate system, the elements 11 to 14 have to change their direction\r\n        const direction = useRightHandedSystem ? -1 : 1;\r\n        const matrix3d = `matrix3d(${\r\n            this._epsilon( elements[0] )\r\n        },${\r\n            this._epsilon( elements[1] )\r\n        },${\r\n            this._epsilon( elements[2] * -direction )\r\n        },${\r\n            this._epsilon( elements[3] )\r\n        },${\r\n            this._epsilon( - elements[4] )\r\n        },${\r\n            this._epsilon( - elements[5] )\r\n        },${\r\n            this._epsilon( elements[6]  * direction )\r\n        },${\r\n            this._epsilon( - elements[7] )\r\n        },${\r\n            this._epsilon( elements[8] * -direction )\r\n        },${\r\n            this._epsilon( elements[9] * -direction )\r\n        },${\r\n            this._epsilon( elements[10] )\r\n        },${\r\n            this._epsilon( elements[11] * direction )\r\n        },${\r\n            this._epsilon( elements[12] * direction )\r\n        },${\r\n            this._epsilon( elements[13] * direction )\r\n        },${\r\n            this._epsilon( elements[14] * direction )\r\n        },${\r\n            this._epsilon( elements[15] )\r\n        })`;\r\n        return matrix3d;\r\n    }\r\n\r\n    protected _getTransformationMatrix(htmlMesh: HtmlMesh, useRightHandedSystem: boolean): Matrix {\r\n        // Get the camera world matrix\r\n        // Make sure the camera world matrix is up to date\r\n        if (!this._cameraWorldMatrix) {\r\n            this._cameraWorldMatrix = htmlMesh.getScene().activeCamera?.getWorldMatrix();\r\n        }\r\n        if (!this._cameraWorldMatrix) {\r\n            return Matrix.Identity();\r\n        }\r\n\r\n        const objectWorldMatrix = htmlMesh.getWorldMatrix();\r\n\r\n        // Scale the object matrix by the base scale factor for the mesh\r\n        // which is the ratio of the mesh width/height to the renderer\r\n        // width/height divided by the babylon units to pixels ratio\r\n        let widthScaleFactor = 1;\r\n        let heightScaleFactor = 1;\r\n        if (htmlMesh.sourceWidth && htmlMesh.sourceHeight) {\r\n            widthScaleFactor = htmlMesh.width! / (htmlMesh.sourceWidth / babylonUnitsToPixels);\r\n            heightScaleFactor = htmlMesh.height! / (htmlMesh.sourceHeight / babylonUnitsToPixels);\r\n        }\r\n\r\n        // Apply the scale to the object's world matrix.  Note we aren't scaling\r\n        // the object, just getting a matrix as though it were scaled, so we can\r\n        // scale the content\r\n        const scaleTransform = this._temp.scaleTransform;\r\n        const rotationTransform = this._temp.rotationTransform;\r\n        const positionTransform = this._temp.positionTransform;\r\n        const scaledAndTranslatedObjectMatrix = this._temp.objectMatrix;\r\n\r\n        objectWorldMatrix.decompose(scaleTransform, rotationTransform, positionTransform);\r\n        scaleTransform.x *= widthScaleFactor;\r\n        scaleTransform.y *= heightScaleFactor;\r\n\r\n        Matrix.ComposeToRef(scaleTransform, rotationTransform, positionTransform, scaledAndTranslatedObjectMatrix);\r\n\r\n        // Adjust direction of 12 and 13 of the transformation matrix based on the handedness of the system\r\n        const direction = useRightHandedSystem ? -1 : 1;\r\n        // Adjust translation values to be from camera vs world origin\r\n        // Note that we are also adjusting these values to be pixels vs Babylon units\r\n        const position = htmlMesh.getAbsolutePosition();\r\n        scaledAndTranslatedObjectMatrix.setRowFromFloats(\r\n            3,\r\n            (-this._cameraWorldMatrix.m[12] + position.x) * babylonUnitsToPixels * direction,\r\n            (-this._cameraWorldMatrix.m[13] + position.y) * babylonUnitsToPixels * direction,\r\n            (this._cameraWorldMatrix.m[14] - position.z) * babylonUnitsToPixels,\r\n            this._cameraWorldMatrix.m[15] * 0.00001 * babylonUnitsToPixels\r\n        );\r\n\r\n        // Adjust other values to be pixels vs Babylon units\r\n        scaledAndTranslatedObjectMatrix.multiplyAtIndex(3, babylonUnitsToPixels);\r\n        scaledAndTranslatedObjectMatrix.multiplyAtIndex(7, babylonUnitsToPixels);\r\n        scaledAndTranslatedObjectMatrix.multiplyAtIndex(11, babylonUnitsToPixels);\r\n\r\n        return scaledAndTranslatedObjectMatrix;\r\n    }\r\n\r\n    protected _renderHtmlMesh(htmlMesh: HtmlMesh, useRightHandedSystem: boolean) {\r\n        if (!htmlMesh.element || !htmlMesh.element.firstElementChild) {\r\n            // nothing to render, so bail\r\n            return;\r\n        }\r\n\r\n        // We need to ensure html mesh data is initialized before\r\n        // computing the base scale factor\r\n        let htmlMeshData = this._cache.htmlMeshData.get(htmlMesh);\r\n        if (!htmlMeshData) {\r\n            htmlMeshData = { style: \"\" };\r\n            this._cache.htmlMeshData.set(htmlMesh, htmlMeshData);\r\n        }\r\n\r\n        const cameraElement = htmlMesh._isCanvasOverlay ? this._overlayElements?.cameraElement : this._inSceneElements?.cameraElement;\r\n\r\n        if (htmlMesh.element.parentNode !== cameraElement) {\r\n            cameraElement!.appendChild(htmlMesh.element);\r\n        }\r\n\r\n        // If the htmlMesh content has changed, update the base scale factor\r\n        if (htmlMesh.requiresUpdate) {\r\n            this._updateBaseScaleFactor(htmlMesh);\r\n        }\r\n\r\n        // Get the transformation matrix for the html mesh\r\n        const scaledAndTranslatedObjectMatrix = this._getTransformationMatrix(htmlMesh, useRightHandedSystem);\r\n\r\n        let style = `translate(-50%, -50%) ${this._getHtmlContentCSSMatrix(scaledAndTranslatedObjectMatrix, useRightHandedSystem)}`;\r\n        // In a right handed system, screens are on the wrong side of the mesh, so we have to rotate by Math.PI which results in the matrix3d seen below\r\n        style += `${useRightHandedSystem ? \"matrix3d(-1, 0, 0, 0, 0, 1, 0, 0, 0, 0, -1, 0, 0, 0, 0, 1)\" : \"\"}`;\r\n\r\n        if (htmlMeshData.style !== style) {\r\n            htmlMesh.element.style.webkitTransform = style;\r\n            htmlMesh.element.style.transform = style;\r\n        }\r\n\r\n        htmlMesh._markAsUpdated();\r\n    }\r\n\r\n    protected _render(scene: Scene, camera: Camera) {\r\n        let needsUpdate = false;\r\n\r\n        const useRightHandedSystem = scene.useRightHandedSystem;\r\n\r\n        // Update the container position and size if necessary\r\n        this._updateContainerPositionIfNeeded();\r\n\r\n        // Check for a camera change\r\n        if (this._cameraMatrixUpdated) {\r\n            this._cameraMatrixUpdated = false;\r\n            needsUpdate = true;\r\n        }\r\n\r\n        // If the camera position has changed, then we also need to update\r\n        if (\r\n            camera.position.x !== this._cache.cameraData.position.x ||\r\n            camera.position.y !== this._cache.cameraData.position.y ||\r\n            camera.position.z !== this._cache.cameraData.position.z\r\n        ) {\r\n            this._cache.cameraData.position.copyFrom(camera.position);\r\n            needsUpdate = true;\r\n        }\r\n\r\n        // Check for a dpr change\r\n        if (window.devicePixelRatio !== this._lastDevicePixelRatio) {\r\n            this._lastDevicePixelRatio = window.devicePixelRatio;\r\n            Logger.Log(\"In render - dpr changed: \", this._lastDevicePixelRatio);\r\n            needsUpdate = true;\r\n        }\r\n\r\n        // Check if any meshes need to be updated\r\n        const meshesNeedingUpdate = scene.meshes.filter((mesh) => (mesh as any)[\"isHtmlMesh\"] && (needsUpdate || (mesh as HtmlMesh).requiresUpdate));\r\n        needsUpdate = needsUpdate || meshesNeedingUpdate.length > 0;\r\n\r\n        if (!needsUpdate) {\r\n            return;\r\n        }\r\n\r\n        // Get a projection matrix for the camera\r\n        const projectionMatrix = camera.getProjectionMatrix();\r\n        const fov = projectionMatrix.m[5] * this._heightHalf;\r\n\r\n        if (this._cache.cameraData.fov !== fov) {\r\n            if (camera.mode == Camera.PERSPECTIVE_CAMERA) {\r\n                [this._overlayElements?.domElement, this._inSceneElements?.domElement].forEach((el) => {\r\n                    if (el) {\r\n                        el.style.webkitPerspective = fov + \"px\";\r\n                        el.style.perspective = fov + \"px\";\r\n                    }\r\n                });\r\n            } else {\r\n                [this._overlayElements?.domElement, this._inSceneElements?.domElement].forEach((el) => {\r\n                    if (el) {\r\n                        el.style.webkitPerspective = \"\";\r\n                        el.style.perspective = \"\";\r\n                    }\r\n                });\r\n            }\r\n            this._cache.cameraData.fov = fov;\r\n        }\r\n\r\n        // Get the CSS matrix for the camera (which will include any camera rotation)\r\n        if (camera.parent === null) {\r\n            camera.computeWorldMatrix();\r\n        }\r\n\r\n        const cameraMatrixWorld = this._temp.cameraWorldMatrix;\r\n        cameraMatrixWorld.copyFrom(camera.getWorldMatrix());\r\n        const cameraRotationMatrix = this._temp.cameraRotationMatrix;\r\n        cameraMatrixWorld.getRotationMatrix().transposeToRef(cameraRotationMatrix);\r\n\r\n        const cameraMatrixWorldAsArray = this._temp.cameraWorldMatrixAsArray;\r\n        cameraMatrixWorld.copyToArray(cameraMatrixWorldAsArray);\r\n\r\n        // For a few values, we have to adjust the direction based on the handedness of the system\r\n        const direction = useRightHandedSystem ? 1 : -1;\r\n\r\n        cameraMatrixWorldAsArray[1] = cameraRotationMatrix.m[1];\r\n        cameraMatrixWorldAsArray[2] = cameraRotationMatrix.m[2] * direction;\r\n        cameraMatrixWorldAsArray[4] = cameraRotationMatrix.m[4] * direction;\r\n        cameraMatrixWorldAsArray[6] = cameraRotationMatrix.m[6] * direction;\r\n        cameraMatrixWorldAsArray[8] = cameraRotationMatrix.m[8] * direction;\r\n        cameraMatrixWorldAsArray[9] = cameraRotationMatrix.m[9] * direction;\r\n\r\n        Matrix.FromArrayToRef(cameraMatrixWorldAsArray, 0, cameraMatrixWorld);\r\n\r\n        const cameraCSSMatrix = this._getCameraCSSMatrix(cameraMatrixWorld);\r\n        const style = cameraCSSMatrix;\r\n\r\n        if (this._cache.cameraData.style !== style) {\r\n            [this._inSceneElements?.cameraElement, this._overlayElements?.cameraElement].forEach((el) => {\r\n                if (el) {\r\n                    el.style.webkitTransform = style;\r\n                    el.style.transform = style;\r\n                }\r\n            });\r\n            this._cache.cameraData.style = style;\r\n        }\r\n\r\n        // _Render objects if necessary\r\n        meshesNeedingUpdate.forEach((mesh) => {\r\n            this._renderHtmlMesh(mesh as HtmlMesh, useRightHandedSystem);\r\n        });\r\n    }\r\n\r\n    protected _updateBaseScaleFactor(htmlMesh: HtmlMesh) {\r\n        // Get screen width and height\r\n        let screenWidth = this._width;\r\n        let screenHeight = this._height;\r\n\r\n        // Calculate aspect ratios\r\n        const htmlMeshAspectRatio = (htmlMesh.width || 1) / (htmlMesh.height || 1);\r\n        const screenAspectRatio = screenWidth / screenHeight;\r\n\r\n        // Adjust screen dimensions based on aspect ratios\r\n        if (htmlMeshAspectRatio > screenAspectRatio) {\r\n            // If the HTML mesh is wider relative to its height than the screen, adjust the screen width\r\n            screenWidth = screenHeight * htmlMeshAspectRatio;\r\n        } else {\r\n            // If the HTML mesh is taller relative to its width than the screen, adjust the screen height\r\n            screenHeight = screenWidth / htmlMeshAspectRatio;\r\n        }\r\n\r\n        // Set content to fill screen so we get max resolution when it is shrunk to fit the mesh\r\n        htmlMesh.setContentSizePx(screenWidth, screenHeight);\r\n    }\r\n\r\n    protected _updateContainerPositionIfNeeded() {\r\n        // Determine if the canvas has moved on the screen\r\n        const canvasRect = this._engine.getRenderingCanvasClientRect();\r\n\r\n        // canvas rect may be null if layout not complete\r\n        if (!canvasRect) {\r\n            Logger.Warn(_positionUpdateFailMessage);\r\n            return;\r\n        }\r\n        const scrollTop = window.scrollY;\r\n        const scrollLeft = window.scrollX;\r\n        const canvasDocumentTop = canvasRect.top + scrollTop;\r\n        const canvasDocumentLeft = canvasRect.left + scrollLeft;\r\n\r\n        if (this._previousCanvasDocumentPosition.top !== canvasDocumentTop || this._previousCanvasDocumentPosition.left !== canvasDocumentLeft) {\r\n            this._previousCanvasDocumentPosition.top = canvasDocumentTop;\r\n            this._previousCanvasDocumentPosition.left = canvasDocumentLeft;\r\n\r\n            [this._inSceneElements?.container, this._overlayElements?.container].forEach((container) => {\r\n                if (!container) {\r\n                    return;\r\n                }\r\n                // set the top and left of the css container to match the canvas\r\n                const containerParent = container.offsetParent as HTMLElement;\r\n                const parentRect = containerParent.getBoundingClientRect();\r\n                const parentDocumentTop = parentRect.top + scrollTop;\r\n                const parentDocumentLeft = parentRect.left + scrollLeft;\r\n\r\n                const ancestorMarginsAndPadding = this._getAncestorMarginsAndPadding(containerParent);\r\n\r\n                // Add the body margin\r\n                const bodyStyle = window.getComputedStyle(document.body);\r\n                const bodyMarginTop = parseInt(bodyStyle.marginTop, 10);\r\n                const bodyMarginLeft = parseInt(bodyStyle.marginLeft, 10);\r\n\r\n                container.style.top = `${canvasDocumentTop - parentDocumentTop - ancestorMarginsAndPadding.marginTop + ancestorMarginsAndPadding.paddingTop + bodyMarginTop}px`;\r\n                container.style.left = `${\r\n                    canvasDocumentLeft - parentDocumentLeft - ancestorMarginsAndPadding.marginLeft + ancestorMarginsAndPadding.paddingLeft + bodyMarginLeft\r\n                }px`;\r\n            });\r\n        }\r\n    }\r\n\r\n    protected _onCameraMatrixChanged = (camera: Camera) => {\r\n        this._cameraWorldMatrix = camera.getWorldMatrix();\r\n        this._cameraMatrixUpdated = true;\r\n    };\r\n\r\n    private _epsilon(value: number) {\r\n        return Math.abs(value) < 1e-10 ? 0 : value;\r\n    }\r\n\r\n    // Get total margins and padding for an element, excluding the body and document margins\r\n    private _getAncestorMarginsAndPadding(element: HTMLElement) {\r\n        let marginTop = 0;\r\n        let marginLeft = 0;\r\n        let paddingTop = 0;\r\n        let paddingLeft = 0;\r\n\r\n        while (element && element !== document.body && element !== document.documentElement) {\r\n            const style = window.getComputedStyle(element);\r\n            marginTop += parseInt(style.marginTop, 10);\r\n            marginLeft += parseInt(style.marginLeft, 10);\r\n            paddingTop += parseInt(style.paddingTop, 10);\r\n            paddingLeft += parseInt(style.paddingLeft, 10);\r\n            element = element.offsetParent as HTMLElement;\r\n        }\r\n\r\n        return { marginTop, marginLeft, paddingTop, paddingLeft };\r\n    }\r\n}\r\n","/******************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\n/* global Reflect, Promise, SuppressedError, Symbol, Iterator */\n\nvar extendStatics = function(d, b) {\n  extendStatics = Object.setPrototypeOf ||\n      ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n      function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n  return extendStatics(d, b);\n};\n\nexport function __extends(d, b) {\n  if (typeof b !== \"function\" && b !== null)\n      throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n  extendStatics(d, b);\n  function __() { this.constructor = d; }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nexport var __assign = function() {\n  __assign = Object.assign || function __assign(t) {\n      for (var s, i = 1, n = arguments.length; i < n; i++) {\n          s = arguments[i];\n          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n      return t;\n  }\n  return __assign.apply(this, arguments);\n}\n\nexport function __rest(s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n      t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n              t[p[i]] = s[p[i]];\n      }\n  return t;\n}\n\nexport function __decorate(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n}\n\nexport function __param(paramIndex, decorator) {\n  return function (target, key) { decorator(target, key, paramIndex); }\n}\n\nexport function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n  function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\n  var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\n  var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\n  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n  var _, done = false;\n  for (var i = decorators.length - 1; i >= 0; i--) {\n      var context = {};\n      for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\n      for (var p in contextIn.access) context.access[p] = contextIn.access[p];\n      context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\n      var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\n      if (kind === \"accessor\") {\n          if (result === void 0) continue;\n          if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\n          if (_ = accept(result.get)) descriptor.get = _;\n          if (_ = accept(result.set)) descriptor.set = _;\n          if (_ = accept(result.init)) initializers.unshift(_);\n      }\n      else if (_ = accept(result)) {\n          if (kind === \"field\") initializers.unshift(_);\n          else descriptor[key] = _;\n      }\n  }\n  if (target) Object.defineProperty(target, contextIn.name, descriptor);\n  done = true;\n};\n\nexport function __runInitializers(thisArg, initializers, value) {\n  var useValue = arguments.length > 2;\n  for (var i = 0; i < initializers.length; i++) {\n      value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n  }\n  return useValue ? value : void 0;\n};\n\nexport function __propKey(x) {\n  return typeof x === \"symbol\" ? x : \"\".concat(x);\n};\n\nexport function __setFunctionName(f, name, prefix) {\n  if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\n  return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\n};\n\nexport function __metadata(metadataKey, metadataValue) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\n}\n\nexport function __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n  return new (P || (P = Promise))(function (resolve, reject) {\n      function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n      function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n      function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n      step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\n\nexport function __generator(thisArg, body) {\n  var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === \"function\" ? Iterator : Object).prototype);\n  return g.next = verb(0), g[\"throw\"] = verb(1), g[\"return\"] = verb(2), typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n  function verb(n) { return function (v) { return step([n, v]); }; }\n  function step(op) {\n      if (f) throw new TypeError(\"Generator is already executing.\");\n      while (g && (g = 0, op[0] && (_ = 0)), _) try {\n          if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n          if (y = 0, t) op = [op[0] & 2, t.value];\n          switch (op[0]) {\n              case 0: case 1: t = op; break;\n              case 4: _.label++; return { value: op[1], done: false };\n              case 5: _.label++; y = op[1]; op = [0]; continue;\n              case 7: op = _.ops.pop(); _.trys.pop(); continue;\n              default:\n                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                  if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                  if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                  if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                  if (t[2]) _.ops.pop();\n                  _.trys.pop(); continue;\n          }\n          op = body.call(thisArg, _);\n      } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n      if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n  }\n}\n\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n  }\n  Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nexport function __exportStar(m, o) {\n  for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\n}\n\nexport function __values(o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n      next: function () {\n          if (o && i >= o.length) o = void 0;\n          return { value: o && o[i++], done: !o };\n      }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\n\nexport function __read(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o), r, ar = [], e;\n  try {\n      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  }\n  catch (error) { e = { error: error }; }\n  finally {\n      try {\n          if (r && !r.done && (m = i[\"return\"])) m.call(i);\n      }\n      finally { if (e) throw e.error; }\n  }\n  return ar;\n}\n\n/** @deprecated */\nexport function __spread() {\n  for (var ar = [], i = 0; i < arguments.length; i++)\n      ar = ar.concat(__read(arguments[i]));\n  return ar;\n}\n\n/** @deprecated */\nexport function __spreadArrays() {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n  for (var r = Array(s), k = 0, i = 0; i < il; i++)\n      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n          r[k] = a[j];\n  return r;\n}\n\nexport function __spreadArray(to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n      if (ar || !(i in from)) {\n          if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n          ar[i] = from[i];\n      }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n}\n\nexport function __await(v) {\n  return this instanceof __await ? (this.v = v, this) : new __await(v);\n}\n\nexport function __asyncGenerator(thisArg, _arguments, generator) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var g = generator.apply(thisArg, _arguments || []), i, q = [];\n  return i = Object.create((typeof AsyncIterator === \"function\" ? AsyncIterator : Object).prototype), verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\n  function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\n  function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\n  function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n  function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n  function fulfill(value) { resume(\"next\", value); }\n  function reject(value) { resume(\"throw\", value); }\n  function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n}\n\nexport function __asyncDelegator(o) {\n  var i, p;\n  return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\n  function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\n}\n\nexport function __asyncValues(o) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var m = o[Symbol.asyncIterator], i;\n  return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n  function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n  function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n}\n\nexport function __makeTemplateObject(cooked, raw) {\n  if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\n  return cooked;\n};\n\nvar __setModuleDefault = Object.create ? (function(o, v) {\n  Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n  o[\"default\"] = v;\n};\n\nvar ownKeys = function(o) {\n  ownKeys = Object.getOwnPropertyNames || function (o) {\n    var ar = [];\n    for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n    return ar;\n  };\n  return ownKeys(o);\n};\n\nexport function __importStar(mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n  __setModuleDefault(result, mod);\n  return result;\n}\n\nexport function __importDefault(mod) {\n  return (mod && mod.__esModule) ? mod : { default: mod };\n}\n\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n}\n\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n}\n\nexport function __classPrivateFieldIn(state, receiver) {\n  if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\n  return typeof state === \"function\" ? receiver === state : state.has(receiver);\n}\n\nexport function __addDisposableResource(env, value, async) {\n  if (value !== null && value !== void 0) {\n    if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\n    var dispose, inner;\n    if (async) {\n      if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\n      dispose = value[Symbol.asyncDispose];\n    }\n    if (dispose === void 0) {\n      if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\n      dispose = value[Symbol.dispose];\n      if (async) inner = dispose;\n    }\n    if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\n    if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };\n    env.stack.push({ value: value, dispose: dispose, async: async });\n  }\n  else if (async) {\n    env.stack.push({ async: true });\n  }\n  return value;\n}\n\nvar _SuppressedError = typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\n  var e = new Error(message);\n  return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\n\nexport function __disposeResources(env) {\n  function fail(e) {\n    env.error = env.hasError ? new _SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\n    env.hasError = true;\n  }\n  var r, s = 0;\n  function next() {\n    while (r = env.stack.pop()) {\n      try {\n        if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);\n        if (r.dispose) {\n          var result = r.dispose.call(r.value);\n          if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) { fail(e); return next(); });\n        }\n        else s |= 1;\n      }\n      catch (e) {\n        fail(e);\n      }\n    }\n    if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();\n    if (env.hasError) throw env.error;\n  }\n  return next();\n}\n\nexport function __rewriteRelativeImportExtension(path, preserveJsx) {\n  if (typeof path === \"string\" && /^\\.\\.?\\//.test(path)) {\n      return path.replace(/\\.(tsx)$|((?:\\.d)?)((?:\\.[^./]+?)?)\\.([cm]?)ts$/i, function (m, tsx, d, ext, cm) {\n          return tsx ? preserveJsx ? \".jsx\" : \".js\" : d && (!ext || !cm) ? m : (d + ext + \".\" + cm.toLowerCase() + \"js\");\n      });\n  }\n  return path;\n}\n\nexport default {\n  __extends,\n  __assign,\n  __rest,\n  __decorate,\n  __param,\n  __esDecorate,\n  __runInitializers,\n  __propKey,\n  __setFunctionName,\n  __metadata,\n  __awaiter,\n  __generator,\n  __createBinding,\n  __exportStar,\n  __values,\n  __read,\n  __spread,\n  __spreadArrays,\n  __spreadArray,\n  __await,\n  __asyncGenerator,\n  __asyncDelegator,\n  __asyncValues,\n  __makeTemplateObject,\n  __importStar,\n  __importDefault,\n  __classPrivateFieldGet,\n  __classPrivateFieldSet,\n  __classPrivateFieldIn,\n  __addDisposableResource,\n  __disposeResources,\n  __rewriteRelativeImportExtension,\n};\n","import { Tools } from \"core/Misc/tools\";\r\n\r\n// A capture management system to ensure that the correct object has the pointer\r\n// events by eliminating race conditions that can cause the pointer events to be\r\n// released by a different object after they are captured leaving no object\r\n// as the owner.  It does this by queueing requests and only allowing\r\n// capture when the current capture owner releases pointer events.\r\n\r\ntype CaptureReleaseCallback = () => void;\r\n\r\ntype CaptureReleaseCallbacks = {\r\n    capture: CaptureReleaseCallback;\r\n    release: CaptureReleaseCallback;\r\n};\r\n\r\nlet captureRequestQueue: string[] = [];\r\n\r\n// Key is request id, value is object with capture and release callbacks\r\nconst pendingRequestCallbacks: Map<string, CaptureReleaseCallbacks> = new Map();\r\n\r\n// Keep track of release requests with no matching capture request\r\n// in case the release request arrived before the capture to avoid\r\n// the capture request never getting released.\r\nlet unmatchedReleaseRequests: string[] = [];\r\n\r\nlet currentOwner: string | null = null; // Called on first capture or release request\r\n\r\n/**\r\n * Get the id of the object currently capturing pointer events\r\n * @returns The id of the object currently capturing pointer events\r\n * or null if no object is capturing pointer events\r\n */\r\nexport const getCapturingId = () => {\r\n    return currentOwner;\r\n};\r\n\r\n/**\r\n * Request that the object with the given id capture pointer events.  If there is no current\r\n * owner, then the request is granted immediately.  If there is a current owner, then the request\r\n * is queued until the current owner releases pointer events.\r\n * @param requestId An id to identify the request.  This id will be used to match the capture\r\n * request with the release request.\r\n * @param captureCallback The callback to call when the request is granted and the object is capturing\r\n * @param releaseCallback The callback to call when the object is no longer capturing pointer events\r\n */\r\nexport const requestCapture = (requestId: string, captureCallback: CaptureReleaseCallback, releaseCallback: CaptureReleaseCallback) => {\r\n    debugLog(`In pointerEventsCapture.requestCapture - Pointer events capture requested for ${requestId}`);\r\n\r\n    // If there is a release for this request, then ignore the request\r\n    if (removeUnmatchedRequest(requestId)) {\r\n        debugLog(`In pointerEventsCapture.requestCapture - Capture request matched previous release request ${requestId}.  Cancelling capture request`);\r\n        return;\r\n    } else if (requestId !== currentOwner) {\r\n        // if the request is not already in the queue, add it to the queue\r\n        enqueueCaptureRequest(requestId, captureCallback, releaseCallback);\r\n    }\r\n\r\n    if (!currentOwner) {\r\n        // If there is no current owner, go ahead and grant the request\r\n        transferPointerEventsOwnership();\r\n    }\r\n    // If the request id is the current owner, do nothing\r\n};\r\n\r\n/**\r\n * Release pointer events from the object with the given id.  If the object is the current owner\r\n * then pointer events are released immediately.  If the object is not the current owner, then the\r\n * associated capture request is removed from the queue.  If there is no matching capture request\r\n * in the queue, then the release request is added to a list of unmatched release requests and will\r\n * negate the next capture request with the same id.  This is to guard against the possibility that\r\n * the release request arrived before the capture request.\r\n * @param requestId The id which should match the id of the capture request\r\n */\r\nexport const requestRelease = (requestId: string | null) => {\r\n    debugLog(`In pointerEventsCapture.requestRelease - Pointer events release requested for ${requestId}`);\r\n\r\n    // if the requestId is the current capture holder release it\r\n    if (!requestId || requestId === currentOwner) {\r\n        transferPointerEventsOwnership();\r\n    } else if (cancelRequest(requestId)) {\r\n        // if the request is in the queue, but not the current capture holder, remove it and it's callbacks\r\n        pendingRequestCallbacks.delete(requestId);\r\n    } else {\r\n        debugLog(`In pointerEventsCapture.requestRelease - Received release request ${requestId} but no matching capture request was received`);\r\n        // request was not current and not in queue, likely because we received a release\r\n        // request before the capture.  Add it to the unmatched list to guard against this possibility\r\n        if (!unmatchedReleaseRequests.includes(requestId)) {\r\n            unmatchedReleaseRequests.push(requestId);\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Relase pointer events from the current owner\r\n */\r\nexport const releaseCurrent = () => {\r\n    requestRelease(currentOwner);\r\n};\r\n\r\nconst enqueueCaptureRequest = (requestId: string, capture: CaptureReleaseCallback, release: CaptureReleaseCallback) => {\r\n    debugLog(`In pointerEventsCapture.enqueueCaptureRequest - Enqueueing capture request for  ${requestId}`);\r\n    if (!captureRequestQueue.includes(requestId)) {\r\n        captureRequestQueue.push(requestId);\r\n        pendingRequestCallbacks.set(requestId, { capture, release });\r\n    }\r\n};\r\n\r\n// Removes the request from the queue if it exists.  Returns true\r\n// if the request was found and removed, otherwise false\r\nconst cancelRequest = (requestId: string | null) => {\r\n    let removed = false;\r\n    captureRequestQueue = captureRequestQueue.filter((id) => {\r\n        if (id !== requestId) {\r\n            return true;\r\n        } else {\r\n            removed = true;\r\n            debugLog(`In pointerEventsCapture.cancelRequest - Canceling pointer events capture request ${requestId}`);\r\n            return false;\r\n        }\r\n    });\r\n    return removed;\r\n};\r\n\r\nconst removeUnmatchedRequest = (requestId: string) => {\r\n    let removed = false;\r\n    unmatchedReleaseRequests = unmatchedReleaseRequests.filter((id) => {\r\n        if (id !== requestId) {\r\n            return true;\r\n        } else {\r\n            removed = true;\r\n            return false;\r\n        }\r\n    });\r\n    return removed;\r\n};\r\n\r\nconst transferPointerEventsOwnership = () => {\r\n    const newOwnerId = nextCaptureRequest();\r\n    debugLog(`In pointerEventsCapture.transferPointerEventsOwnership - Transferrring pointer events from ${currentOwner} to ${newOwnerId}`);\r\n    // Release the current owner\r\n    doRelease();\r\n    if (newOwnerId) {\r\n        doCapture(newOwnerId);\r\n    }\r\n};\r\n\r\nconst doRelease = () => {\r\n    debugLog(`In pointerEventsCapture.doRelease - Releasing pointer events from ${currentOwner}`);\r\n    if (currentOwner) {\r\n        // call the release callback\r\n        pendingRequestCallbacks.get(currentOwner)?.release();\r\n        // And remove the callbacks\r\n        pendingRequestCallbacks.delete(currentOwner);\r\n        currentOwner = null;\r\n    }\r\n};\r\n\r\nconst doCapture = (newOwnerId: string) => {\r\n    if (newOwnerId) {\r\n        // call the capture callback\r\n        pendingRequestCallbacks.get(newOwnerId)?.capture();\r\n    }\r\n    currentOwner = newOwnerId;\r\n    debugLog(`In pointerEventsCapture.doCapture - Pointer events now captured by ${newOwnerId}`);\r\n};\r\n\r\nconst nextCaptureRequest = () => {\r\n    return captureRequestQueue.length > 0 ? captureRequestQueue.shift() : null;\r\n};\r\n\r\n// #region Debugging support\r\ndeclare global {\r\n    interface Window {\r\n        // eslint-disable-next-line @typescript-eslint/naming-convention\r\n        \"pointer-events-capture-debug\": boolean | null;\r\n    }\r\n}\r\n\r\nconst debugLog = (message: string) => {\r\n    // If we are runnning in a test runner (in node, so window is not defined)\r\n    // or if the debug flag is set, then log the message\r\n    if (typeof window === \"undefined\" || window[\"pointer-events-capture-debug\"]) {\r\n        Tools.Log(\r\n            `${performance.now()} - game.scene.pointerEvents - ${message}\\ncurrentOwner: ${currentOwner}\\nqueue: ${captureRequestQueue}\\nunmatched: ${unmatchedReleaseRequests}`\r\n        );\r\n    }\r\n};\r\n// #endregion Debugging support\r\n","import type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport type { Behavior } from \"core/Behaviors/behavior\";\r\nimport type { Scene } from \"core/scene\";\r\nimport { Logger } from \"core/Misc/logger\";\r\nimport { requestCapture, requestRelease, releaseCurrent, getCapturingId } from \"./pointerEventsCapture\";\r\n\r\n// Module level variable for holding the current scene\r\nlet _scene: Scene | null = null;\r\n\r\n// Module level variable to hold the count of behavior instances that are currently capturing pointer events\r\n// on entry.  This is used to determine if we need to start or stop observing pointer movement.\r\nlet captureOnEnterCount = 0;\r\n\r\n// Map used to store instance of the PointerEventsCaptureBehavior for a mesh\r\n// We do this because this gets checked on pointer move and we don't want to\r\n// use getBehaviorByName() because that is a linear search\r\nconst meshToBehaviorMap = new WeakMap<AbstractMesh, PointerEventsCaptureBehavior>();\r\n\r\nconst startCaptureOnEnter = (scene: Scene) => {\r\n    // If we are not in a browser, do nothing\r\n    if (typeof document === \"undefined\") {\r\n        return;\r\n    }\r\n    if (captureOnEnterCount === 0) {\r\n        document.addEventListener(\"pointermove\", onPointerMove);\r\n        document.addEventListener(\"touchstart\", onPointerMove);\r\n        _scene = _scene ?? scene;\r\n        Logger.Log(\"PointerEventsCaptureBehavior: Starting observation of pointer move events.\");\r\n        _scene.onDisposeObservable.add(doStopCaptureOnEnter);\r\n    }\r\n    captureOnEnterCount++;\r\n};\r\n\r\nconst doStopCaptureOnEnter = () => {\r\n    document.removeEventListener(\"pointermove\", onPointerMove);\r\n    document.removeEventListener(\"touchstart\", onPointerMove);\r\n    _scene = null;\r\n    Logger.Log(\"PointerEventsCaptureBehavior: Stopping observation of pointer move events.\");\r\n    captureOnEnterCount = 0;\r\n};\r\n\r\nconst stopCaptureOnEnter = () => {\r\n    // If we are not in a browser, do nothing\r\n    if (typeof document === \"undefined\") {\r\n        return;\r\n    }\r\n\r\n    // If we are not observing pointer movement, do nothing\r\n    if (!_scene) {\r\n        return;\r\n    }\r\n\r\n    captureOnEnterCount--;\r\n    if (captureOnEnterCount <= 0) {\r\n        doStopCaptureOnEnter();\r\n    }\r\n};\r\n\r\n// Module level function used to determine if an entered mesh should capture pointer events\r\nconst onPointerMove = (evt: PointerEvent | TouchEvent) => {\r\n    if (!_scene) {\r\n        return;\r\n    }\r\n\r\n    const canvasRect = _scene.getEngine().getRenderingCanvasClientRect();\r\n    if (!canvasRect) {\r\n        return;\r\n    }\r\n\r\n    // Get the object that contains the client X and Y from either the pointer event or from the\r\n    // TouchEvent touch\r\n    const { clientX, clientY } = \"touches\" in evt ? evt.touches[0] : evt;\r\n\r\n    // get the picked mesh, if any\r\n    const pointerScreenX = clientX - canvasRect.left;\r\n    const pointerScreenY = clientY - canvasRect.top;\r\n\r\n    let pointerCaptureBehavior: PointerEventsCaptureBehavior | undefined;\r\n    const pickResult = _scene.pick(pointerScreenX, pointerScreenY, (mesh) => {\r\n        // If the mesh has an instance of PointerEventsCaptureBehavior attached to it,\r\n        // and capture on pointer enter is true, then we want to pick it\r\n        const pointerCaptureBehavior = meshToBehaviorMap.get(mesh);\r\n        return mesh.isEnabled() && typeof pointerCaptureBehavior !== \"undefined\" && pointerCaptureBehavior._captureOnPointerEnter;\r\n    });\r\n\r\n    let pickedMesh: AbstractMesh | null;\r\n    if (pickResult.hit) {\r\n        pickedMesh = pickResult.pickedMesh;\r\n    } else {\r\n        pickedMesh = null;\r\n    }\r\n\r\n    const capturingIdAsInt = parseInt(getCapturingId() || \"\");\r\n\r\n    // if the picked mesh is the current capturing mesh, do nothing\r\n    if (pickedMesh && pickedMesh.uniqueId === capturingIdAsInt) {\r\n        return;\r\n    }\r\n\r\n    // If there is a capturing mesh and it is not the current picked mesh, or no\r\n    // mesh is picked, release the capturing mesh\r\n    if (capturingIdAsInt && (!pickedMesh || pickedMesh.uniqueId !== capturingIdAsInt)) {\r\n        releaseCurrent();\r\n    }\r\n\r\n    // If there is a picked mesh and it is not the current capturing mesh, capture\r\n    // the pointer events.  Note that the current capturing mesh has already been\r\n    // released above\r\n    if (pickedMesh) {\r\n        pointerCaptureBehavior = meshToBehaviorMap.get(pickedMesh);\r\n        pointerCaptureBehavior!.capturePointerEvents();\r\n    }\r\n};\r\n\r\n/**\r\n * Behavior for any content that can capture pointer events, i.e. bypass the Babylon pointer event handling\r\n * and receive pointer events directly.  It will register the capture triggers and negotiate the capture and\r\n * release of pointer events.  Curerntly this applies only to HtmlMesh\r\n */\r\nexport class PointerEventsCaptureBehavior implements Behavior<AbstractMesh> {\r\n    /** gets or sets behavior's name */\r\n    public name = \"PointerEventsCaptureBehavior\";\r\n\r\n    private _attachedMesh: AbstractMesh | null;\r\n    /** @internal */\r\n    public _captureOnPointerEnter: boolean;\r\n\r\n    /**\r\n     * Gets or sets the mesh that the behavior is attached to\r\n     */\r\n    public get attachedMesh() {\r\n        return this._attachedMesh;\r\n    }\r\n\r\n    public set attachedMesh(value: AbstractMesh | null) {\r\n        this._attachedMesh = value;\r\n    }\r\n\r\n    constructor(\r\n        private _captureCallback: () => void,\r\n        private _releaseCallback: () => void,\r\n        { captureOnPointerEnter = true } = {}\r\n    ) {\r\n        this._attachedMesh = null;\r\n        this._captureOnPointerEnter = captureOnPointerEnter;\r\n\r\n        // Warn if we are not in a browser\r\n        if (typeof document === \"undefined\") {\r\n            Logger.Warn(`Creating an instance of PointerEventsCaptureBehavior outside of a browser.  The behavior will not work.`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set if the behavior should capture pointer events when the pointer enters the mesh\r\n     */\r\n    public set captureOnPointerEnter(captureOnPointerEnter: boolean) {\r\n        if (this._captureOnPointerEnter === captureOnPointerEnter) {\r\n            return;\r\n        }\r\n        this._captureOnPointerEnter = captureOnPointerEnter;\r\n        if (this._attachedMesh) {\r\n            if (this._captureOnPointerEnter) {\r\n                startCaptureOnEnter(this._attachedMesh.getScene()!);\r\n            } else {\r\n                stopCaptureOnEnter();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Function called when the behavior needs to be initialized (before attaching it to a target)\r\n     */\r\n    public init() {}\r\n\r\n    /**\r\n     * Called when the behavior is attached to a target\r\n     * @param mesh defines the target where the behavior is attached to\r\n     */\r\n    public attach(mesh: AbstractMesh) {\r\n        // Add a reference to this behavior on the mesh.  We do this so we can get a\r\n        // reference to the behavior in the onPointerMove function without relying on\r\n        // getBehaviorByName(), which does a linear search of the behaviors array.\r\n        this.attachedMesh = mesh;\r\n        meshToBehaviorMap.set(mesh, this);\r\n        if (this._captureOnPointerEnter) {\r\n            startCaptureOnEnter(mesh.getScene()!);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called when the behavior is detached from its target\r\n     */\r\n    public detach() {\r\n        if (!this.attachedMesh) {\r\n            return;\r\n        }\r\n        // Remove the reference to this behavior from the mesh\r\n        meshToBehaviorMap.delete(this.attachedMesh);\r\n        if (this._captureOnPointerEnter) {\r\n            stopCaptureOnEnter();\r\n        }\r\n        this.attachedMesh = null;\r\n    }\r\n\r\n    /**\r\n     * Dispose the behavior\r\n     */\r\n    public dispose() {\r\n        this.detach();\r\n    }\r\n\r\n    // Release pointer events\r\n    public releasePointerEvents() {\r\n        if (!this.attachedMesh) {\r\n            return;\r\n        }\r\n        requestRelease(this.attachedMesh.uniqueId.toString());\r\n    }\r\n\r\n    // Capture pointer events\r\n    public capturePointerEvents() {\r\n        if (!this.attachedMesh) {\r\n            return;\r\n        }\r\n        requestCapture(this.attachedMesh.uniqueId.toString(), this._captureCallback, this._releaseCallback);\r\n    }\r\n}\r\n","export type FitStrategyType = {\r\n    wrapElement(element: HTMLElement): HTMLElement;\r\n    updateSize(sizingElement: HTMLElement, width: number, height: number): void;\r\n};\r\n\r\nconst FitStrategyContain: FitStrategyType = {\r\n    wrapElement(element: HTMLElement): HTMLElement {\r\n        const sizingElement = document.createElement(\"div\");\r\n        sizingElement.style.display = \"flex\";\r\n        sizingElement.style.justifyContent = \"center\";\r\n        sizingElement.style.alignItems = \"center\";\r\n        const scalingElement = document.createElement(\"div\");\r\n        scalingElement.style.visibility = \"hidden\";\r\n        scalingElement.appendChild(element);\r\n        sizingElement.appendChild(scalingElement);\r\n        return sizingElement;\r\n    },\r\n    updateSize(sizingElement: HTMLElement, width: number, height: number) {\r\n        const scalingElement = sizingElement.firstElementChild! as HTMLElement;\r\n        sizingElement.style.width = `${width}px`;\r\n        sizingElement.style.height = `${height}px`;\r\n\r\n        const [childWidth, childHeight] = [scalingElement!.offsetWidth, scalingElement!.offsetHeight];\r\n        const scale = Math.min(width / childWidth, height / childHeight);\r\n        scalingElement.style.transform = `scale(${scale})`;\r\n        scalingElement.style.visibility = \"visible\";\r\n    },\r\n};\r\n\r\nconst FitStrategyCover: FitStrategyType = {\r\n    wrapElement(element: HTMLElement): HTMLElement {\r\n        const sizingElement = document.createElement(\"div\");\r\n        sizingElement.style.display = \"flex\";\r\n        sizingElement.style.justifyContent = \"center\";\r\n        sizingElement.style.alignItems = \"center\";\r\n        sizingElement.style.overflow = \"hidden\";\r\n        const scalingElement = document.createElement(\"div\");\r\n        scalingElement.style.visibility = \"hidden\";\r\n        scalingElement.appendChild(element);\r\n        sizingElement.appendChild(scalingElement);\r\n        return sizingElement;\r\n    },\r\n    updateSize(sizingElement: HTMLElement, width: number, height: number) {\r\n        const scalingElement = sizingElement.firstElementChild! as HTMLElement;\r\n        sizingElement.style.width = `${width}px`;\r\n        sizingElement.style.height = `${height}px`;\r\n\r\n        const [childWidth, childHeight] = [scalingElement!.offsetWidth, scalingElement!.offsetHeight];\r\n        const scale = Math.max(width / childWidth, height / childHeight);\r\n        scalingElement.style.transform = `scale(${scale})`;\r\n        scalingElement.style.visibility = \"visible\";\r\n    },\r\n};\r\n\r\nconst FitStrategyStretch: FitStrategyType = {\r\n    wrapElement(element: HTMLElement): HTMLElement {\r\n        const sizingElement = document.createElement(\"div\");\r\n        sizingElement.style.display = \"flex\";\r\n        sizingElement.style.justifyContent = \"center\";\r\n        sizingElement.style.alignItems = \"center\";\r\n        const scalingElement = document.createElement(\"div\");\r\n        scalingElement.style.visibility = \"hidden\";\r\n        scalingElement.appendChild(element);\r\n        sizingElement.appendChild(scalingElement);\r\n        return sizingElement;\r\n    },\r\n    updateSize(sizingElement: HTMLElement, width: number, height: number) {\r\n        const scalingElement = sizingElement.firstElementChild! as HTMLElement;\r\n        sizingElement.style.width = `${width}px`;\r\n        sizingElement.style.height = `${height}px`;\r\n\r\n        const [childWidth, childHeight] = [scalingElement!.offsetWidth, scalingElement!.offsetHeight];\r\n        scalingElement.style.transform = `scale(${width / childWidth}, ${height / childHeight})`;\r\n        scalingElement.style.visibility = \"visible\";\r\n    },\r\n};\r\n\r\nconst FitStrategyNone: FitStrategyType = {\r\n    wrapElement(element: HTMLElement): HTMLElement {\r\n        return element;\r\n    },\r\n    updateSize(sizingElement: HTMLElement, width: number, height: number) {\r\n        if (sizingElement) {\r\n            sizingElement.style.width = `${width}px`;\r\n            sizingElement.style.height = `${height}px`;\r\n        }\r\n    },\r\n};\r\n\r\nexport const FitStrategy = {\r\n    CONTAIN: FitStrategyContain,\r\n    COVER: FitStrategyCover,\r\n    STRETCH: FitStrategyStretch,\r\n    NONE: FitStrategyNone,\r\n};\r\n","import { Mesh } from \"core/Meshes/mesh\";\r\nimport { CreatePlaneVertexData } from \"core/Meshes/Builders/planeBuilder\";\r\nimport { StandardMaterial } from \"core/Materials/standardMaterial\";\r\nimport { Matrix } from \"core/Maths/math\";\r\nimport { PointerEventsCaptureBehavior } from \"./pointerEventsCaptureBehavior\";\r\nimport type { Scene } from \"core/scene\";\r\nimport { Logger } from \"core/Misc/logger\";\r\nimport type { FitStrategyType } from \"./fitStrategy\";\r\nimport { FitStrategy } from \"./fitStrategy\";\r\n\r\n/**\r\n * This class represents HTML content that we want to render as though it is part of the scene.  The HTML content is actually\r\n * rendered below the canvas, but a depth mask is created by this class that writes to the depth buffer but does not\r\n * write to the color buffer, effectively punching a hole in the canvas.  CSS transforms are used to scale, translate, and rotate\r\n * the HTML content so that it matches the camera and mesh orientation.  The class supports interactions in editable and non-editable mode.\r\n * In non-editable mode (the default), events are passed to the HTML content when the pointer is over the mask (and not occluded by other meshes\r\n * in the scene).\r\n * @see https://playground.babylonjs.com/#HVHYJC#5\r\n * @see https://playground.babylonjs.com/#B17TC7#112\r\n */\r\nexport class HtmlMesh extends Mesh {\r\n    /**\r\n     * Helps identifying a html mesh from a regular mesh\r\n     */\r\n    public get isHtmlMesh() {\r\n        return true;\r\n    }\r\n\r\n    // Override the super class's _isEnabled property so we can control when the mesh\r\n    // is enabled.  I.e., we don't want to render the mesh until there is content to show.\r\n    private _enabled = false;\r\n\r\n    // The mesh is ready when content has been set and the content size has been set\r\n    // The former is done by the user, the latter is done by the renderer.\r\n    private _ready = false;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _isCanvasOverlay = false;\r\n\r\n    private _requiresUpdate = true;\r\n\r\n    private _element?: HTMLElement;\r\n    private _width?: number;\r\n    private _height?: number;\r\n\r\n    private _inverseScaleMatrix: Matrix | null = null;\r\n\r\n    private _captureOnPointerEnter: boolean = true;\r\n    private _pointerEventCaptureBehavior: PointerEventsCaptureBehavior | null = null;\r\n\r\n    private _sourceWidth: number | null = null;\r\n    private _sourceHeight: number | null = null;\r\n\r\n    /**\r\n     * Return the source width of the content in pixels\r\n     */\r\n    public get sourceWidth() {\r\n        return this._sourceWidth;\r\n    }\r\n\r\n    /**\r\n     * Return the source height of the content in pixels\r\n     */\r\n    public get sourceHeight() {\r\n        return this._sourceHeight;\r\n    }\r\n\r\n    private _worldMatrixUpdateObserver: any;\r\n\r\n    private _fitStrategy: FitStrategyType = FitStrategy.NONE;\r\n\r\n    /**\r\n     * Contruct an instance of HtmlMesh\r\n     * @param scene\r\n     * @param id The id of the mesh.  Will be used as the id of the HTML element as well.\r\n     * @param options object with optional parameters\r\n     */\r\n    constructor(scene: Scene, id: string, { captureOnPointerEnter = true, isCanvasOverlay = false, fitStrategy = FitStrategy.NONE } = {}) {\r\n        super(id, scene);\r\n\r\n        // Requires a browser to work.  Bail if we aren't running in a browser\r\n        if (typeof document === \"undefined\") {\r\n            Logger.Warn(`Creating an instance of an HtmlMesh with id ${id} outside of a browser.  The mesh will not be visible.`);\r\n            return;\r\n        }\r\n\r\n        this._fitStrategy = fitStrategy;\r\n        this._isCanvasOverlay = isCanvasOverlay;\r\n        this._createMask();\r\n        this._element = this._createElement();\r\n\r\n        // Set enabled by default, so this will show as soon as it's ready\r\n        this.setEnabled(true);\r\n\r\n        this._captureOnPointerEnter = captureOnPointerEnter;\r\n\r\n        // Create a behavior to capture pointer events\r\n        this._pointerEventCaptureBehavior = new PointerEventsCaptureBehavior(this.capturePointerEvents.bind(this), this.releasePointerEvents.bind(this), {\r\n            captureOnPointerEnter: this._captureOnPointerEnter,\r\n        });\r\n        this.addBehavior(this._pointerEventCaptureBehavior);\r\n    }\r\n\r\n    /**\r\n     * The width of the content in pixels\r\n     */\r\n    public get width() {\r\n        return this._width;\r\n    }\r\n\r\n    /**\r\n     * The height of the content in pixels\r\n     */\r\n    public get height() {\r\n        return this._height;\r\n    }\r\n\r\n    /**\r\n     * The HTML element that is being rendered as a mesh\r\n     */\r\n    public get element() {\r\n        return this._element;\r\n    }\r\n\r\n    /**\r\n     * True if the mesh has been moved, rotated, or scaled since the last time this\r\n     * property was read.  This property is reset to false after reading.\r\n     */\r\n    public get requiresUpdate() {\r\n        return this._requiresUpdate;\r\n    }\r\n\r\n    /**\r\n     * Enable capture for the pointer when entering the mesh area\r\n     */\r\n    public set captureOnPointerEnter(captureOnPointerEnter: boolean) {\r\n        this._captureOnPointerEnter = captureOnPointerEnter;\r\n        if (this._pointerEventCaptureBehavior) {\r\n            this._pointerEventCaptureBehavior.captureOnPointerEnter = captureOnPointerEnter;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes of the mesh and the HTML element\r\n     */\r\n    public override dispose() {\r\n        super.dispose();\r\n        this._element?.remove();\r\n        this._element = undefined;\r\n        if (this._pointerEventCaptureBehavior) {\r\n            this._pointerEventCaptureBehavior.dispose();\r\n            this._pointerEventCaptureBehavior = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _markAsUpdated() {\r\n        this._requiresUpdate = false;\r\n    }\r\n\r\n    /**\r\n     * Sets the content of the element to the specified content adjusting the mesh scale to match and making it visible.\r\n     * If the the specified content is undefined, then it will make the mesh invisible.  In either case it will clear the\r\n     * element content first.\r\n     * @param element The element to render as a mesh\r\n     * @param width The width of the mesh in Babylon units\r\n     * @param height The height of the mesh in Babylon units\r\n     */\r\n    setContent(element: HTMLElement, width: number, height: number) {\r\n        // If content is changed, we are no longer ready\r\n        this._setAsReady(false);\r\n\r\n        // Also invalidate the source width and height\r\n        this._sourceWidth = null;\r\n        this._sourceHeight = null;\r\n\r\n        if (!this._element) {\r\n            return;\r\n        }\r\n\r\n        this._width = width;\r\n        this._height = height;\r\n        this._requiresUpdate = true;\r\n\r\n        this.scaling.setAll(1);\r\n\r\n        if (element) {\r\n            this._element!.appendChild(this._fitStrategy.wrapElement(element));\r\n\r\n            this._updateScaleIfNecessary();\r\n        }\r\n\r\n        if (this.sourceWidth && this.sourceHeight) {\r\n            this._setAsReady(true);\r\n        }\r\n    }\r\n\r\n    // Overides BABYLON.Mesh.setEnabled\r\n    public override setEnabled(enabled: boolean) {\r\n        // Capture requested enabled state\r\n        this._enabled = enabled;\r\n\r\n        // If disabling or enabling and we are ready\r\n        if (!enabled || this._ready) {\r\n            this._doSetEnabled(enabled);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the content size in pixels\r\n     * @param width width of the source\r\n     * @param height height of the source\r\n     */\r\n    public setContentSizePx(width: number, height: number) {\r\n        this._sourceWidth = width;\r\n        this._sourceHeight = height;\r\n\r\n        if (!this._element || !this._element.firstElementChild) {\r\n            return;\r\n        }\r\n\r\n        this._fitStrategy.updateSize(this._element.firstElementChild! as HTMLElement, width, height);\r\n\r\n        this._updateScaleIfNecessary();\r\n\r\n        if (this.width && this.height) {\r\n            this._setAsReady(true);\r\n        }\r\n    }\r\n\r\n    protected _setAsReady(ready: boolean) {\r\n        this._ready = ready;\r\n        if (ready) {\r\n            this._doSetEnabled(this._enabled);\r\n        } else {\r\n            this._doSetEnabled(false);\r\n        }\r\n    }\r\n\r\n    protected _doSetEnabled(enabled: boolean) {\r\n        if (!this._element) {\r\n            return;\r\n        }\r\n\r\n        //if enabled, then start listening for changes to the\r\n        // scaling, rotation, and position.  otherwise stop listening\r\n        if (enabled && !this._worldMatrixUpdateObserver) {\r\n            this._worldMatrixUpdateObserver = this.onAfterWorldMatrixUpdateObservable.add(() => {\r\n                this._requiresUpdate = true;\r\n            });\r\n        } else if (!enabled) {\r\n            this._worldMatrixUpdateObserver?.remove();\r\n            this._worldMatrixUpdateObserver = null;\r\n        }\r\n\r\n        // If enabled, then revert the content element display\r\n        // otherwise hide it\r\n        this._element!.style.display = enabled ? \"\" : \"none\";\r\n        // Capture the content z index\r\n        this._setElementZIndex(this.position.z * -10000);\r\n        super.setEnabled(enabled);\r\n    }\r\n\r\n    protected _updateScaleIfNecessary() {\r\n        // If we have setContent before, the content scale is baked into the mesh.  If we don't reset the vertices to\r\n        // the original size, then we will multiply the scale when we bake the scale below.  By applying the inverse, we back out\r\n        // the scaling that has been done so we are starting from the same point.\r\n        // First reset the scale to 1\r\n        this.scaling.setAll(1);\r\n        // Then back out the original vertices changes to match the content scale\r\n        if (this._inverseScaleMatrix) {\r\n            this.bakeTransformIntoVertices(this._inverseScaleMatrix);\r\n            // Clear out the matrix so it doesn't get applied again unless we scale\r\n            this._inverseScaleMatrix = null;\r\n        }\r\n\r\n        // Set scale to match content.  Note we can't just scale the mesh, because that will scale the content as well\r\n        // What we need to do is compute a scale matrix and then bake that into the mesh vertices.  This will leave the\r\n        // mesh scale at 1, so our content will stay it's original width and height until we scale the mesh.\r\n        const scaleX = this._width || 1;\r\n        const scaleY = this._height || 1;\r\n        const scaleMatrix = Matrix.Scaling(scaleX, scaleY, 1);\r\n        this.bakeTransformIntoVertices(scaleMatrix);\r\n\r\n        // Get an inverse of the scale matrix that we can use to back out the scale changes we have made so\r\n        // we don't multiply the scale.\r\n        this._inverseScaleMatrix = new Matrix();\r\n        scaleMatrix.invertToRef(this._inverseScaleMatrix);\r\n    }\r\n\r\n    protected _createMask() {\r\n        const vertexData = CreatePlaneVertexData({ width: 1, height: 1 });\r\n        vertexData.applyToMesh(this);\r\n\r\n        const scene = this.getScene();\r\n        this.checkCollisions = true;\r\n\r\n        const depthMask = new StandardMaterial(`${this.id}-mat`, scene);\r\n        if (!this._isCanvasOverlay) {\r\n            depthMask.backFaceCulling = false;\r\n            depthMask.disableColorWrite = true;\r\n            depthMask.disableLighting = true;\r\n        }\r\n\r\n        this.material = depthMask;\r\n\r\n        // Optimization - Freeze material since it never needs to change\r\n        this.material.freeze();\r\n    }\r\n\r\n    protected _setElementZIndex(zIndex: number) {\r\n        if (this._element) {\r\n            this._element!.style.zIndex = `${zIndex}`;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Callback used by the PointerEventsCaptureBehavior to capture pointer events\r\n     */\r\n    capturePointerEvents() {\r\n        if (!this._element) {\r\n            return;\r\n        }\r\n\r\n        // Enable dom content to capture pointer events\r\n        this._element.style.pointerEvents = \"auto\";\r\n\r\n        // Supress events outside of the dom content\r\n        document.getElementsByTagName(\"body\")[0].style.pointerEvents = \"none\";\r\n    }\r\n\r\n    /**\r\n     * Callback used by the PointerEventsCaptureBehavior to release pointer events\r\n     */\r\n    releasePointerEvents() {\r\n        if (!this._element) {\r\n            return;\r\n        }\r\n\r\n        // Enable pointer events on canvas\r\n        document.getElementsByTagName(\"body\")[0].style.pointerEvents = \"auto\";\r\n\r\n        // Disable pointer events on dom content\r\n        this._element.style.pointerEvents = \"none\";\r\n    }\r\n\r\n    protected _createElement() {\r\n        // Requires a browser to work.  Bail if we aren't running in a browser\r\n        if (typeof document === \"undefined\") {\r\n            return;\r\n        }\r\n        const div = document.createElement(\"div\");\r\n        div.id = this.id;\r\n        div.style.backgroundColor = this._isCanvasOverlay ? \"transparent\" : \"#000\";\r\n        div.style.zIndex = \"1\";\r\n        div.style.position = \"absolute\";\r\n        div.style.pointerEvents = \"none\";\r\n        div.style.backfaceVisibility = \"hidden\";\r\n\r\n        return div;\r\n    }\r\n}\r\n","// eslint-disable-next-line import/no-internal-modules\r\nimport * as addons from \"addons/index\";\r\n\r\nexport { addons };\r\nexport default addons;\r\n"],"names":["root","factory","exports","module","require","define","amd","self","global","this","__WEBPACK_EXTERNAL_MODULE__597__","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","d","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","r","Symbol","toStringTag","value","babylonUnitsToPixels","renderOrderFunc","defaultRenderOrder","subMeshA","subMeshB","meshA","getMesh","meshB","meshAIsHtmlMesh","meshBIsHtmlMesh","absolutePosition","z","scene","parentContainerId","_containerId","enableOverlayRender","defaultOpaqueRenderOrder","RenderingGroup","PainterSortCompare","defaultAlphaTestRenderOrder","defaultTransparentRenderOrder","defaultTransparentSortCompare","_cache","cameraData","fov","position","Vector3","style","htmlMeshData","WeakMap","_width","_height","_heightHalf","_temp","scaleTransform","rotationTransform","Quaternion","positionTransform","objectMatrix","Matrix","Identity","cameraWorldMatrix","cameraRotationMatrix","cameraWorldMatrixAsArray","Array","_lastDevicePixelRatio","window","devicePixelRatio","_cameraMatrixUpdated","_previousCanvasDocumentPosition","top","left","_renderObserver","_onCameraMatrixChanged","camera","_cameraWorldMatrix","getWorldMatrix","document","_init","dispose","remove","_overlayElements","container","_inSceneElements","parentContainer","getElementById","body","inSceneContainerId","_createRenderLayerElements","insertBefore","firstChild","overlayContainerId","zIndex","getEngine","getRenderingCanvas","pointerEvents","_engine","projectionObs","matrixObs","clientRect","getRenderingCanvasClientRect","Error","_setSize","width","height","onResizeObservable","add","observeCamera","activeCamera","onProjectionMatrixChangedObservable","onViewMatrixChangedObservable","onActiveCameraChanged","opaqueRenderOrder","alphaTestRenderOrder","transparentRenderOrder","setRenderingOrder","onBeforeRenderObservable","_render","containerId","existingContainer","createElement","id","domElement","overflow","cameraElement","webkitTransformStyle","transformStyle","appendChild","_getSize","forEach","dom","_getCameraCSSMatrix","matrix","elements","m","_epsilon","_getHtmlContentCSSMatrix","useRightHandedSystem","direction","_getTransformationMatrix","htmlMesh","getScene","objectWorldMatrix","widthScaleFactor","heightScaleFactor","sourceWidth","sourceHeight","scaledAndTranslatedObjectMatrix","decompose","x","y","ComposeToRef","getAbsolutePosition","setRowFromFloats","multiplyAtIndex","_renderHtmlMesh","element","firstElementChild","set","_isCanvasOverlay","parentNode","requiresUpdate","_updateBaseScaleFactor","webkitTransform","transform","_markAsUpdated","needsUpdate","_updateContainerPositionIfNeeded","copyFrom","Logger","Log","meshesNeedingUpdate","meshes","filter","mesh","length","getProjectionMatrix","mode","Camera","PERSPECTIVE_CAMERA","el","webkitPerspective","perspective","parent","computeWorldMatrix","cameraMatrixWorld","getRotationMatrix","transposeToRef","cameraMatrixWorldAsArray","copyToArray","FromArrayToRef","screenWidth","screenHeight","htmlMeshAspectRatio","setContentSizePx","canvasRect","scrollTop","scrollY","scrollLeft","scrollX","canvasDocumentTop","canvasDocumentLeft","containerParent","offsetParent","parentRect","getBoundingClientRect","parentDocumentTop","parentDocumentLeft","ancestorMarginsAndPadding","_getAncestorMarginsAndPadding","bodyStyle","getComputedStyle","bodyMarginTop","parseInt","marginTop","bodyMarginLeft","marginLeft","paddingTop","paddingLeft","Warn","Math","abs","documentElement","extendStatics","b","setPrototypeOf","__proto__","p","create","SuppressedError","captureRequestQueue","pendingRequestCallbacks","Map","unmatchedReleaseRequests","currentOwner","requestRelease","requestId","debugLog","cancelRequest","delete","includes","push","transferPointerEventsOwnership","removed","newOwnerId","nextCaptureRequest","doRelease","doCapture","release","capture","shift","message","Tools","performance","now","_scene","captureOnEnterCount","meshToBehaviorMap","startCaptureOnEnter","addEventListener","onPointerMove","onDisposeObservable","doStopCaptureOnEnter","removeEventListener","stopCaptureOnEnter","evt","pickedMesh","touches","clientX","clientY","pointerScreenX","pointerScreenY","pickResult","pick","pointerCaptureBehavior","isEnabled","_captureOnPointerEnter","hit","capturingIdAsInt","uniqueId","capturePointerEvents","_captureCallback","_releaseCallback","captureOnPointerEnter","name","_attachedMesh","init","attach","attachedMesh","detach","releasePointerEvents","toString","captureCallback","releaseCallback","removeUnmatchedRequest","enqueueCaptureRequest","FitStrategy","CONTAIN","wrapElement","sizingElement","display","justifyContent","alignItems","scalingElement","visibility","updateSize","offsetWidth","offsetHeight","childWidth","childHeight","scale","min","COVER","max","STRETCH","NONE","isCanvasOverlay","fitStrategy","_enabled","_ready","_requiresUpdate","_inverseScaleMatrix","_pointerEventCaptureBehavior","_sourceWidth","_sourceHeight","_fitStrategy","_createMask","_element","_createElement","setEnabled","PointerEventsCaptureBehavior","bind","addBehavior","TypeError","String","__","constructor","setContent","_setAsReady","scaling","setAll","_updateScaleIfNecessary","enabled","_doSetEnabled","ready","_worldMatrixUpdateObserver","onAfterWorldMatrixUpdateObservable","_setElementZIndex","bakeTransformIntoVertices","scaleX","scaleY","scaleMatrix","Scaling","invertToRef","CreatePlaneVertexData","applyToMesh","checkCollisions","depthMask","StandardMaterial","backFaceCulling","disableColorWrite","disableLighting","material","freeze","getElementsByTagName","div","backgroundColor","backfaceVisibility","Mesh"],"sourceRoot":""}